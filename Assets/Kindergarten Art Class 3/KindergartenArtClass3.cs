using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[ExecuteInEditMode]
public class KindergartenArtClass3 : MonoBehaviour
{
    [Header("Buf A")]
    public Shader m_bufAShader = null;
    public Texture m_bufAChannel1Input = null;

    private Material m_bufAMat = null;
    private RenderTexture m_bufA = null;

    [Header("Image")]
    public Shader m_imageShader = null;

    private Material m_imageMat = null;
    // RenderTexture not needed if we want to render to screen

    static class Uniforms
    {
        internal static readonly int _MousePos = Shader.PropertyToID("_MousePos");
        internal static readonly int _Channel0 = Shader.PropertyToID("_Channel0");
        internal static readonly int _Channel1 = Shader.PropertyToID("_Channel1");
        internal static readonly int _Channel2 = Shader.PropertyToID("_Channel2");
    }

    private void OnDisable()
    {
        if (m_bufA != null)
        {
            DestroyImmediate(m_bufA);
        }
    }

    private void OnPreCull()
    {
        if (m_bufA == null)
        {
            m_bufA = new RenderTexture(Screen.width, Screen.height, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear) { name = "[AutoGenerated]KindergartenArtClass3-BufA" };
        }

        MatchRenderTextureSize(m_bufA, Screen.width, Screen.height);

        SetUpMaterial(ref m_bufAMat, m_bufAShader);
        SetUpMaterial(ref m_imageMat, m_imageShader);
    }

    private void OnPostRender()
    {
        if (m_bufA != null && m_bufAMat != null)
        {
            var screenTarget = RenderTexture.active;

            // pass mouse position like ShaderToy
            Vector4 mousePos = Input.mousePosition;
            mousePos.z = mousePos.w = Input.GetMouseButton(0) ? 1 : 0;
            m_bufAMat.SetVector(Uniforms._MousePos, mousePos);

            // pass input channels
            m_bufAMat.SetTexture(Uniforms._Channel0, m_bufA);
            m_bufAMat.SetTexture(Uniforms._Channel1, m_bufAChannel1Input);

            // we need to render to a temporary buffer because rendering to a buffer that is used as shader input causes problems
            var tempBuf = RenderTexture.GetTemporary(m_bufA.width, m_bufA.height, m_bufA.depth, m_bufA.format, RenderTextureReadWrite.Linear, m_bufA.antiAliasing);
            Graphics.Blit(null, tempBuf, m_bufAMat);
            Graphics.Blit(tempBuf, m_bufA);
            RenderTexture.ReleaseTemporary(tempBuf);

            // render to screen and use Image shader if set
            if (m_imageMat != null)
            {
                m_imageMat.SetTexture(Uniforms._Channel0, m_bufA);
                Graphics.Blit(null, screenTarget, m_imageMat);
            }
            else
            {
                Graphics.Blit(m_bufA, screenTarget);
            }
        }
    }

    private void SetUpMaterial(ref Material mat, Shader shader)
    {
        if (mat == null || mat.shader != shader)
        {
            if (shader != null)
                mat = new Material(shader);
            else
                mat = null;
        }
    }

    private void MatchRenderTextureSize(RenderTexture t, int width, int height)
    {
        if (t.width != width || t.height != height)
        {
            t.Release();
            t.width = width;
            t.height = height;
            t.Create();
        }
    }
}
